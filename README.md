Questions:

1. why hook: 
    1. no this
    2. no binding
    3. decouple logic from UI, create custom hook
    4. don’t need to care about life-cycle
2. functional programming: 
    1. pure function
    2. avoid side-effect
    3. simple function composition
    4. js support: HOC, function as param/value, closure, anonymous function
3. favor composition over inheritance:
    1. avoid class hierarchies
    2. avoid tight coupling
    3. base class problem
    4. code flexible
4. event loop:
    1. main stack
    2. event queue
    3. promise queue
5. closure: combination of function bundled together with references to its surrounding state (lexical environment). In JS, closures are created everytime a fucntion is created, at function creation time
6. function composition: combine 2+ functions to create a new function
7. promise: an object produce a single value some time in the future, has 3 posible states: fullfilled, rejected, pending
8. Javascript comparision ==, falsy, truthy
9. React Componnet: class/function that returns React element which is an object describe of an HTML element, React component or mix of these (https://www.freecodecamp.org/news/react-interview-question-what-gets-rendered-in-the-browser-a-component-or-an-element-1b3eac777c85/#:~:text=A%20React%20Element%20is%20what,the%20component's%20render%20function%20returns.)
    1. React component: template/blueprint can be either a function or a class 
    2. React element: is what get returned from component. It’s an object describe DOM node that component represents. It’s not what we see in browser/screen, just object in memory.
    3. Functional component don’t have instances
    4. ReactDOM render DOM elements 
10. Nullish coalescing, optional chaning
11. Prototype: mechanism by which JavaScript objects inherit features from one another.
12. 
